#+title: Alghoritmen und Datenstruktur 1
#+SETUPFILE: ~/roam/ost_exam_summary_setup.conf

#+LATEX: \begin{multicols}{3}
* General
** Arithmetic sequences
*n-element*:
- recursive: $a_n = a_{n-1} + d; a_1 = c$
- iterative: $a_n = a_1 + \sum_{i=2}^n d$
- explicit: $a_n = a_1 + d(n-1)$ 

*Sum*:
- recursive: $s_1 = c, s_n = s_{n-1} + d$
- itertive: $s_n = \sum_{i=1}^{n}i$
- explicit: $s_n = \frac{n(a_1 + a_n)}{2}$
** Paradigms for Algorithm Design
- Brute Force (determine the max. with a loo)
- Greedy
- Divide & Conquer
- Dynamic Programming (dynamic bottom-up Fibonacci)

*** Divide & Conquer
Divide the problem into two smaller sub-problems. Do this until the sub-problems are so small that it is trivially to solve it.

** Linear Recursion
linear recursion checks first if the the base case is fulfilled. If not go further with recursion.

** Tail Recursion
A tail recursion is when the linear recursive method as the last step does the recursive call. This function are simple to rewrite in a non-recursive manner.

** Binary Recursion
Binary recursion is a function which has two recursive calls in all non-base cases (e.g. Tower on Hanoi)

** TODO Analysis
The analysis of a algorithm is determined independent of HW and SW. Then the primitives steps in the algorithm are counted. HW and SW changes the run time of an algorithm, but not the amount of steps. After analysis you have something like =8n-2= steps in worst case. The Big-Oh Notation focus more on how the running time changes proportionally to n. For example $3n^3 + 20^n + 5 = O(n^3)$.
#+LATEX: \newpage
* Algorithms
** Tree Traversal
For trees different traversal methods exists:
- *Preorder*: node is visited before its successors
- *Postorder*: node is visited after its successors
- *Breadth-First*: visit all nodes from depth t before t+1
- *Inorder*: visit after right, visit before left

The *Euler Traversal* is a generic traversal for binary trees. Each node is visited three times, first from left (preorder), from the bottom (inoder) and at last from right (postorder). With the *Template Method Pattern* the main algorithm (Euler Traversal) is written in a base class and subclasses will refine the algorithm without changing the structure.

#+begin_src java
  public abstract class EulerTour {
      protected BinaryTree tree;
      protected void visitExernal(Position p, Result r) {};
      protected void visitLeft(Position p, Result r) {};
      protected void visitBelow(Position p, Result r) {};
      protected void visitRight(Position p, Result r) {};
      protected Object eulerTour(Position p) {
          Result r = new Result();
          if (tree.isExternal(p,r)) {
              visitExternal(p,r);
          }
          else {
              visitLeft(p,r);
              r.leftResult = eulerTour(tree.left(p));
              visitBelow(p, r);
              r.rightResult = eulerTour(tree.right(p));
              return r.finalResult;
          }
          return r.finalResult;
      }
  }
#+end_src

** Selection-Sort
PQ sort with a unsorted list has a running time of O(n^2). Can be implemented in place just with the source data structure.
** Insertion-Sort
PQ sort with a sorted list has a running time of O(n^2). Can be implemented in place just with the source data structure.

** Heap Sort
Uses a Heap as sorting data structure an has a running time of (log n) and is a lot faster than Select / Insertion sort.
#+LATEX: \newpage
* Data Structures
** Comparator
A Comparator hides the comperation between two objects. The methods for the Comperator are:
- =Integer compare(a,b)=: returns < 0 if a < b, 0 if a = b or > 0 if a > b
** Linked-Lists
Linked List is a list where multiple knotes are linked together. The normal =LinkedList= is no synchronized. Thanks to this better in performance, but in multi threaded dangerous. To use a synchronized list use =List list = Collections.synchronizedList(new LinkedList());=

*** Singly-Linked-List
In the Singly-Linked-List each node stores a reference to the next element in the list. Normally the head and tail are stored separately in the Data structure. It's only possible to traverse the list from head to tail.
#+begin_src java
  void addFirst(Node v) {
      v.setNext(head);
      head = v;
      size = size + 1;
  }
  
  void addLast(Node v) {
      v.setNext(null);
      tail.setNext(v);
      tail = v;
      size = size + 1;
  }
  
  void removeFirst(Node v) {
      if (head == null) {
          throw new Exception("Empty");
      }
      Node t = head;
      head = head.getNext();
      t.setNext(null);
      size = size - 1;
  }
#+end_src

*** Doubly-Linked-List
Each node has store a reference to the next and the previous node. Normally the header and trailer are special nodes (*Sentinels* or *Guards*). Header and trailer are start nodes for the search.
#+begin_src java
  void addFirst(Node v) {
      Node w = header.getNext();
      v.setNext(w);
      v.setPrev(header);
      w.setPrev(v);
      header.setNext(v);
      size = size + 1;
  }

  // Insert v after u
  void addAfter(Node u, Node v) { 
      Node w = u.getNext();
      v.setPrev(u);
      v.setNext(w);
      w.setPrev(v);
      u.setNext(v);
  
      size = size + 1;
  }
  
  void removeLast(Node v) {
      if (size == 0) {
          throw new Exception("Empty");
      }
      Node v = trailer.getPrev();
      Node u = v.getPrev();
      trailer.setPrev(u);
      u.setNext(trailer);
      v.setPrev(null);
      v.setNext(null);
      size = size - 1;
  }
  
  void remove(Node v) {
      Node u = v.getPrev();
      Node w = v.getNext();
      w.setPrev(u);
      u.setNext(w);
      v.setPrev(null);
      v.setNext(null);
      size = size - 1;
  }
#+end_src

*** Circularly-Linked-Lists
If the last node of a linked list is linked to first node it is a Circulary-Linked-List.

** Stacks
A Stack stores various object according to the LIFO scheme (last-in, first-out). The main operations are:
- =push(Object)=: add an element
- =Object pop()=: removes and returns the top element

The following operations are normally also implemented:
- =Object top()=: returns the top element
- =int size()=: returns the number of elements
- =boolean isEmpty()=: checks if stack is empty

*** Array-based Stacks
The elements are stored in the array and are stored from left to right. In a variable $t$ the is the index stored from the top element.
#+begin_src java
  int size() {
      return t + 1;
  }
  
  object pop() {
      if (isEmpty()) {
          return null;
      }
      else {
          t = t - 1;
          return S[t + 1];
      }
  }
#+end_src

When adding itmes to the stack / array it could happen that no space is left in the array. In this case a =IllegalStateException= could be thrown which is specific to this implementation.

#+begin_src java
  object push(object o) {
      if (t == S.length - 1) {
          thrown new IllegalStateException();
      }
      else {
          t = t + 1;
          S[t] = o;
      }
  }
#+end_src

For such an implementation all operations need O(1) time and O(n) storage. But the max size is fix and is specified over the constructor. If the max size is exceeded a implementation specific Exception is thrown.

*** List-based Stacks 
A stack could also implemented on top of a Single-Linked-List using the Adapter Patterns.

** Queue
A queue stores various objects in a FIFO (first-in first-out) schema. The elements are inserted at the end. Important operations are:
- =enqueue(Object)=: inserts an element at the end
- =Object dequeue()=: removes and returns the element at the begining

The support operations are:
- =Object first()=: returns the first element
- =integer size()=: returns the amount of objects stored
- =boolean isEmpty()=: checks if queue is empty

If the queue is empty and the =dequeue= / =first= action is performed =null= is returned.

The array is used in circular manner. With two variables are the front (f) and the current amount of elements (sz) stored. The first empty slot at the end of the queue is calculated with $r = (f + sz) mod N$

#+begin_src java
  void enqueue(object o) {
      if (sz == N) {
          throw new IllegalStateException();
      }
      else {
          int r = (f + sz) % N;
          Q[r] = o;
          sz = sz + +;
      }
  }
#+end_src
If the array is full an exception is thrown.

#+begin_src java
  void dequeue() {
      if (isEmpty()) {
          return null;
      }
      else {
          object o = Q[f];
          f = (f+1) % N;
          sz = (sz - 1);
          return o;
      }
  }
#+end_src

The =java.util.Queue= has another naming for the functions. But apart from this it's pretty similar.
| ADT        | throws exception | special value |
|------------+------------------+-----------------------|
| enqueue(e) | add(e)           | offer(e)              |
| dequeue()  | remove(e)        | poll()                |
| first()    | element()        | peek()                |
| size()     | size()           | size()                |
| isEmpty()  | isEmpty()        | isEmpty()             |
*** List based Queues
** Deque
Double-Ended-Queue stores various objects in a FIFO scheme. Inserting and removing happens at the front or at the end. Important operations:
- =addFirst(object e)=: inserts an element at the begin
- =addLast(object e)=: inserts an element the end
- =object removeFirst()=: removes the first element and returns it
- =object removeLast()=: removes the last element and returns it
- =object E first()=: returns the first element
- =object E last()=: returns the last element

Java has an interface Deque which is implemented by many classes: =ArrayDeque, ConcurrentLinkedDeque, LinkedBlockingDeque, LinkedList=
Trying to read from an empty queue returns =null=. The element of the deque are doubly linked nodes. Thanks to this the basic operation of the Deque are very fast:
| Method                  | O-Performance |
|-------------------------+---------------|
| size, isEmpty           | O(1)          |
| getFirst, getLast       | O(1)          |
| addFirst, addLast       | O(1)          |
| removeFirst, removeLast | O(1)          |
** Positional lists
The *Position* ADT represents the idea of /Place/ in a data structure.

The *Positional-List* ADT represents the idea of a sequence of Positions. Additional a previous / next relation between the positions is created. Access methods returns a Position:
- =first(), last()=
- =before(p), after(p)=

Update Methods:
- =E set(p, e)=
- =Position addFirst(e)=
- =Position addLast(e)=
- =Position addBefore(p, e)=
- =Position addAfter(p, e)=
- =E remove(p)=

Additional methods:
- =Iterator<E> iterator()=
- =Iterable<Position<E>> positions()=

The PositionalList is simple to implement using a doubly linked list. The nodes form the list stores the element and references to the previous and next element.
#+begin_src java
  void addAfter(Node p, Node e) {
      Node v = new Node();
      v.setElement(e);
      v.setPrev(p);
      v.setNext(p.getNext());
      (p.getNext()).setPrev(v);
      p.setNext(v);
      return v;
  }
  
  void remove(Node p) {
      object t = p.element;
      (p.getPrev()).setNext(p.getNext());
      (p.getNext()).setPrev(p.getPrev());
      p.setPrev(null);
      p.setNext(null);
      return t;
  }
#+end_src

All operations for the Positional list ADT needs O(1) time execept for searching. Searching needs O(n) time.

** Tree
A tree data structure represented abstract, hierarchical structure. A tree consists of node which have a parent-child relation.

| root                   | node without a parent node              |
| internal node / branch | node with min. one child                |
| external node / leaf   | node without child nodes                |
| predecessor node       | parent, great parents, ...              |
| depth                  | number of predecessors                  |
| height of a node       | external: 0;                            |
|                        | internal: 1 + max height all successors |
| height of the tree     | height of the root                      |
| successor              | child node, ...                         |


*depth*: depth is the number of predecessor v without v itself. 
#+begin_src java
  int depth(Tree T, Node v) {
      if (T.isRoot(v)) {
          return 0;
      } else {
          return 1+ depth(T, v.parent());
      }
  }
#+end_src

*height*: height is equal to the greatest depth of a tree.
#+begin_src java
  int height(Position<E> v) {
      int h = 0;
      for(Position w : children(v)) {
          h = Math.max(h, 1 + height(w));
      }
      return h;
  }
  
#+end_src
*** ADT
Access method:
- =Position root()=
- =Position parent(p)=
- =PostionList children(p)=
- =Integer numChildren(p)=

Query methods:
- =Boolean isInternal(p)=
- =Boolean isExternal(p)=
- =Boolean isRoot(p)=


Support methods:
- =Integer size()=
- =Boolean isEmpty()=
- =Iterator iterator()=
  

*** Binary Tree
A binary tree is tree which each node has max. two child nodes. A *real binary tree* has every internal node exact two child nodes. For the BinaryTree ADT has the following additional methods:
- =Position left(p)=
- =Position right(p)=
- =Position sibling(p)=

A binary tree the following properties (n: number of nodes, e: number of externals, i: number of internals, h: height)
\begin{align*}
e &= i + 1 \leftrightarrow i = e - 1 \\
n &= i + e = i + i + 1 \\
&= 2i + 1 = 2e - 1 \\
e &= (n+1)/2 \\
i &= (n-1)/2 \\
e &\leq 2^h \\
h &\geq \log_2(e) \\
h &\geq \log_2(n+1)-1 \\
n &\leq 2^{h+1}-1 \\
h &\leq i \\
h &\leq (n-1)/2 \\
n &\geq 2h + 1
\end{align*}

Properties of a real binary tree:
\begin{align*}
e &= i + 1 \\
n &= 2e - 1 \\
h &\leq i \\
h &\leq (n-1)/2 \\
e &\leq 2^h \\
h &\geq \log_2(e) \\
h &\geq \log_2(n+1)-1
\end{align*}

*** Linked based
Each node stores the Element, has a reference to the parent node and has a reference to a list of its children. For the Binary Tree it is simpler. Just store the references to the left / right directly in the node.

*** Array based
Each node is stored in a specific location in the array. The index for the node is calculated as follows:
\begin{align*}
f(p) = \begin{cases}
0, \quad \text{if p is root} \\
2f(q) + 1, \quad \text{if p is left child of q} \\
2f(q) + 2, \quad \text{if p is right child of q}
\end{cases}
\end{align*}

** Priority Queue (PQ)
*** Priority Queue ADT
A Priority Queue stores a collection of Entries. Each entry is a key-value pair. The most important functions are:
- =insert(k,v)=
- =removeMin()=

Additional methods:
- =min()=
- =size()=
- =isEmpty()=

The PriorityQueue Entry (Key-Value-Pair) has the following methods:
- =key()=
- =value()=

*** Sorting with PQ
#+begin_src java
  List<T> pq_sort(List<T> s, Comperator c) {
      PriorityQueue<T> pq = new PriorityQueue();
      while(!s.isEmpty()) {
          T e = s.remove(s.first());
          pq.insert(e, null);
      }
  
      while(!pq.isEmpty()) {
          T e = pq.removeMin().key();
          s.addLast(e)
      }
  }
#+end_src

Performance:
|               | insert | removeMin / min |
| unsorted list | O(1)   | O(n)            |
| sorted list   | O(n)   | O(1)            |

PQ-sort with a unsorted list is called *selection-sort*, with a sorted list *insertion-sort*
** Heap
Heap is a binary tree which stores in its nodes keys and has the following properties: for each node v which is not the root applies $key(v) \leq key(parent(v))$. Additional properties (h=height)
- for i=0, ..., h-1 on each level 2^i nodes
- filling up from left to right
- max. one node with only one child
- the last node is the farthest right on level h
- heap with n nodes has height $\lfloor \log n \rfloor$


*** Priority Queues with Heap
The Heap stores key-value entries on each node and also the last node is stored in the data structure. The =insert()= method inserts the new element at the last position and then the *upheap* action is performed to restore the heap. Upheap compares the new inserted element with its parent until it is the root or the parent key is smaller or equal to its own key (O(log n)). The =removeMin()= method removes the root and the last element of the heap in inserted as root. After this the *downheap* action is performed to restore the heap. Downheap compares the new root with its children and swaps with the smaller one until node is a leaf or the children nodes are greater or equal.

** Adaptable Priority Queue
The idea of the Adaptable PQ is that the data structure creates the entries and returns it to the user. The entry stores the key, value and the position of the item in the list (index, pointers, ...). The position is updated if swaps occurs.
*** ADT
- =remove(e)=: removes Entry e and returns e
- =replaceKey(e,k)=: key is replace from entry and old key is returned
- =replaceValue(e,v)=: value is replace from entry and old value is returned
  
*** Heap implementation
A location aware heap entry stores the key, value, and the current position inside the heap. Each heap node stores a such an entry. All Pointers are updated during swaps.

** Maps
Map represents a searchable collection of Key-Value entries. For each key only one entry is allowed.
*** ADT
- =get(k)=: returns the entry with key k; else null
- =put(k, v)=: if a entry with key exists the value is updated and old value is returned; else a new entry is created and null is returned
- =remove(k)=: removes entry with key k and returns it; if not exists returns null
- =size(), isEmpty()=
- =keySet()=: returns a iterable collection of the keys
- =values()=: returns a iterable collection of the values (duplicates are possible)
- =entrySet()=: returns a iterable collection with all entries


*** list based
With an unsorted list it is simple to implement the Map ADT. 

#+begin_src java
  object get(Key k) {
      var B = S.positions();
      while (B.hasNext()) {
          Entry p = B.next();
          if (p.element().key() == k)
              return p.element().value();
      }
      return null;
  }
#+end_src

#+begin_src java
  object put(Key k, Value v) {
      var B = S.positions();
      while(B.hasNext()) {
          Entry p = B.next();
          if (p.element().key() == k) {
              Value t = p.element().value();
              S.set(p, (k,v));
              return t;
          }
      }
      S.addLast((k,v));
      n = n + 1;
      return null;
  }
#+end_src

#+begin_src java
  object remove(Key k) {
      var B = S.positions();
      while (B.hasNext()) {
          p = B.next();
          if (p.element().key() == k) {
              Value t = p.element().value();
              S.remove(p);
              n = n - 1;
              return t;
          }
          return null;
      }
  }
#+end_src

The running time of the unsorted list based map:
- =put=: O(n), insertion itself is O(1) but first the whole list has to be search for possible occurence
- =get=: O(n)
- =remove=: O(n)

**** Sentinel trick

In the previous algorithms two queries are required (=while(B.hasNext()= and =if (p.element().key() = k=). With the insertion of a special node at the end with the searched key, only one query is left (=while(p.element().key !=k=). If a node is found (you found always a node) you only have to check if the node is a real one or the sentinel.

** Multi map
Similar to a map. But a multi map can store to a key multiple values. One possible solution is to adjust the data structure or the key points to a collection with the values of k.

*** ADT
- =get(k)=
- =put(k, v,)=
- =remove(k,v)=
- =removeAll(k)=
- =size()=
- =entries()=: returns a collection of all entries
- =keys()=: returns a collection of keys for all entries in the multi map (including duplicates for keys with multiple bindings)
- =keySet()=: returns a non duplicative collection of keys 
- =values()=: returns a collection of values for all entries
** Set
A set is a unsorted collection of elements without duplicates. The elements of a set are the keys of a map but without a value.:w
*** ADT
- =add(e)=
- =remove(e)=
- =contains(e)=
- =iterator()=
- =union(), intersection(), substraction=
- =addAll(T)=
- =retainAll(T)=
- =removeAll(T)=

*** list based
The elements are sorted based on a defined order. Needed storage is O(n). A generic merge looks as follow. This algorithm uses again the Template Pattern. The running time is O(n_A + N_B).
#+begin_src java
  Set generictMerge(Set A, Set B) {
      Set S = new Set();
      while (!A.isEmpty() && !B.isEmpty()) {
          object a = A.first().element();
          object b = B.first().element();
          if (a < b) {
              aIsLess(a, S);
              A.remove(A.first());
          } else if (b < a) {
             bIsLess(b, S);
             B.remove(B.first()); 
          } else {
              bothAreEqual(a, b, S);
              A.remove(A.first());
              B.remove(B.first());
          }
      }
      while (!A.isEmpty()) {
          aIsLess(a, S);
          A.remove(A.first());
      }
  
      while (!B.isEmpty()) {
          bIsLess(b, S);
          B.remove(B.first());
      }
  
      return S;
  }
#+end_src
*** Multiset
A set where duplicates are allowed.

** Hash Tables
*** Hash functions
A hash function maps a key on integers in a fixed interval [0; N-1]. For example $h(x) = x \mod \, N$ is a hash function. A hash function can have two anomalies: *gaps* (space is wasted) and *collisions* (two different keys, same hash). A *perfect* hash function has no collisions. A hash function consists normally of two parts: *Hash code* (Key -> Integers) and the compression function (integer -> [0; N-1]). The goal of the hash function is distribute the keys as randomly as possible and the goal of the compression function is to transform the keys in a specific interval.

*Hash codes*:
- memory address: the location in the memory is used (default for Java)
- integer cast: the key is interpreted as integer
- component sum: key is separated in groups (fixed length) and then a sum is builded (overflow is ignored)
- polynomial accumulation: dived bits of key in components and calculate polynomial (a_0 + a_1z + a_2z^2...), good for strings


*Compression function*:
- Division (Modulo): $h_2(y) = y \mod \, N$, N size of table normally a prim number
- Multiply, Add and Divide (MAD): $h_2(y) = ((ay + b) \mod \, p) \mod \, N$, p is prim and bigger than N, a and b are arbitary numbers between [0, p-1] and a > 0


*** Collision handling
Most hashing procedures are different in its collision handling. It exists two methods how collisions can be handled:
- separate chaining (buckets in a linked list)
- open addressing (inserts in an other bucket)

With separate chaining in each cell a list based map is inserted. With linear probing the collision is solved in which you inserts the item in the next available cell. Linear negative probe search backwards in the table. With Quadratic probing is not 1 added to the index but the quadratic. With alternating probing forward and backward (linear and quadratic). And random probing finds a new index with a fix random function.

The remove operation in open addressing needs special treatment. If the item is normally removed a other item may not be found anymore. For each cell a state needs to be saved (free, used, deleted). During probing deleted cells are treated as used.

Double hashing uses a second hash function in case a collision is occurred: $(h(k) + jd(k)) \mod \, N$ (j = Number of collisions, for all k: d(k) != 0, N has to be prime). The second compression functions is normally: $d(k) = q -k \mod q$ where q < N and q is prime.


Worst Case all elements leads to collisions: O(n) for search, insert, remove. But if the hash values are distributed evenly then the numbers of access is $\frac{1}{1-a}$ (*load factor* $a = \frac{n}{N}$). The expected running time for all Map ADT is O(1). If the load factor is not to near at 1 (100%) then hashing is very efficient. *Rehash*: rebuild of the hash table with greater capacity.
  
*** Hash tables
Hash tables consists of hash function h and an array (table) of length N. In a map implementation using a Hash table the goal is that the entry (k,v) at the index i = h(k) is stored.

** Skip Listen
A Skip List consists of a series of lists. Each list  has a artificial start and end node ($-\infty, +\infty$). The list S_0 contains all keys in a ascending order. In a *perfect skip list* every list has in the middle a element.

*Searching* in the skip list:
1. Starting in the first element in the first element
2. At a position p compare x with $y = key(next(p))$
   - x = y: return element(next(p))
   - x > y: scan forward
   - x < y: drop down
3. If we reached the bottom and should drop down further then return null

*Insertion* in the skip list (k,o):
1. Search unsuccessfully for k. The search ended at p_0 with the biggest key smaller than k
2. creates new node p with Key k and randomly chosen height after the key p_0
3. collect all nodes which points "through" p and adjust the connections


*Remove* entry (e) from the skip list:
1. search e in the skip list, find the positions in the all the lists (p_0, p_1, ..., p_i)
2. remove the positions p_0, p_1, ..., p_i from the lists S_0, S_1, ..., S_2
3. Remove all lists which contains only the first ($-\infty) and the last node (+\infty)


*Storage analysis*: the expected amount of nodes is:
\begin{equation*}
\sum_{i=0}^h \frac{n}{2^i} = n \sum_{i=0}^h\frac{1}{2^i} < 2n
\end{equation*}
The skip lists needs O(n) memory.

*Time analysis*: the expected time for search, insertion and removing is (log n)

* End

#+LATEX: \end{multicols}
